5-3 DOM 엘리먼트에 대한 참조 유지하기
useRef 훅을 호출해서 버튼이나 폼 필등체 대한 참조를 쉽게 저장할 수 있다. 이런 DOM 엘리먼트에 대한 참조를 사용하면 리액트 상태에서 UI에 이르는 일반적인 리액트 흐름을 우회하면서 엘리먼트와 직접 상호작용할 수 있다.<br/>
리액트가 DOM 엘리먼트 참조를 참조객체의 current 프로퍼티에 자동으로 대입하게 만드는 방법을 통해 해당 엘리먼트를 직접 조작하거나 읽을 수 있다.<br/>

5-3-1 이벤트에 응답해 엘리먼트에 포커스 설정하기<br/>
리액트를 사용한다면 가능한 한 리액트의 상태 ui 흐름 안에 머무르려한다.<br/>
직접 DON에 접근하는 타이밍은 리액트가 상태 변경에 대응해 DOM을 갱신하는 것으로 인해 복잡해질 수 있다. 또 동일한 컴포넌트가 앱에 여러 번 쓰인 경우 고유한 ID 애트리뷰트로 컴포넌트의 엘리먼트를 식별하면 문제를 해결하기보다<br/>
문제를 야기하기 쉽다. <br/>
이 문제는 리액트의 useRef 훅으로 생성된 참조객체에 자동으로 DOM 엘리먼트 참조를 대입하는 방법을 제공한다.<br/>

리스트 5.3 참조객체를 사용해 포커스 설정하기 (참고)

리스트 5.3을 보면 코드에서 useRef에 초기값을 지정하지 않는다.<br/>
리액트가 프로퍼티에 자동으로 값을 대입하게 하기 때문이다.<br/>
우리가 DOM에 직접 접근하는 대신 사용자 인터페이스를 위한 JSX의 버튼에 있는 ref 애트리뷰트에 대해 useRef에서 얻은 참조객체를 대입한다.<br/>

5-3-2 참조객체를 사용해 텍스트 박스 관리하기<br/>

리스트 5.4 텍스트 박스와 Go 버튼이 추가된 WeekPicker 참조<br/>

-제어되지 않는 컴포넌트<br/>
이 예제에서 컴포넌트는 텍스트 박스의 상태를 관리하지 않는다. 컴포넌트는 사용자가 하는 일에 아무런 관심이 없다. <br/>
브라우저는 사용자가 입력한 새 문자를 표시한다.<br/>
사용자가 Go 버튼을 클릭하는 경우에만 참조객체를 통해 DOM에서 텍스트 상태를 읽고 리듀서에게 전달한다.<br/>
이런 방식으로  DOM이 상태를 관리하도록 내버려둔 컴포넌트라고 해서 "제어되지 않는 컴포넌트" 라고 한다.<br/>

-제어되는 컴포넌트<br/>
제어 컴포넌트를 사용하면 데이터가 컴포넌트에서 DOM 방향으로 흘러가며, 리액트의 표준 접근 방식과 일치한다.<br/>

5.4요약<br/>
  -상태 값을 관리하되 상태 변경 시 리액트가 UI를 재렌더링하는 일을 피하고 싶을 때 useRef 훅을 사용한다.<br/>
  -컴포넌트가 실행될 때 같은 useRef는 current 프로퍼티에 원하는 값을 대입한다.<br/>
  -리액트는 DOM 엘리먼트 참조를 자동으로 참조객체의 current 프로퍼티에 대입할 수 있다. jsx에서 ref 애트리뷰트에 참조객체 변수를 대입하면 된다.<br/>
  -DOM 엘리먼트와 상호작용하기 위해 참조객체를 사용하라. 예로 포커스를 엘리먼트로 이동시키기 위해 다음과 같이 할 수 있다<br/>
    myRef.current,focus();<br/>
  -DOM에서 상태를 읽는 컴포넌트를 "제어되지 않는 컴포넌트"라고 한다. 참조객체를 사용해 제어되지 않는 컴포넌트의 상태를 읽거나 변경할 수 있다.<br/>
  -리액트에서 "제어되는 컴포넌트"를 사용하는 편이 낫다. useState 훅이나 useReducer 훅을 써서 상태를 관리하고 최신 상태 값을 사용해 DOM을 갱신하도록 한다.<br/>


6장 애플리케이션 상태 관리하기<br/>
useState,useReducer,useRef 훅을 써서 컴포넌트가 자체적인 상태 관리하는 방법과 useEffect 훅을 써서 상태 데이터를 적재하는 방법을 살펴봤다.<br/>
그러나 컴포넌트가 함께 UI를 생성하면서 작동하려면 공유 상태 값을 사용하는 것이 일반적이다. 각 컴포넌트에는 하위 컴포넌트가 계층 구조로 있으며, 상태 값을 하위 계층까지 내려보낼 수 있어야 한다.<br/>
6장에서는 상태를 하위 컴포넌트에 전달하기 위해 프롭을 사용하는 방법을 알아본다.<br/>

6-1 자식 컴포넌트에게 공유 상태 전달하기<br/>
여러 컴포넌트가 UI룰 구성하기 위해 같은 데이터를 사용할 떄, 이런 데이터를 가장 명시적으로 공유하는 방법은 부모에서 자식으로 전달하는 프롭(Prop)을 통해 공유할 상태를 전달한다.<br/>

6-1-1 부모가 자식의 프롭을 설정함으로써 상태를 자식에게 전달하는 방법<br/>
리스트 6.1 참조<br/>
리스트6.1은 세 가지 하위 컴포넌트를 임포트한다. 각 하위 컴포넌트에는 사용자가 선택한 색상이 필요하기 때문에 Colors 컴포넌트가 해당 상태를 보유하고 프롭을 통해 하위 컴포넌트에게 전달한다.<br/>
또한 Colors 컴포넌트는 사용 가능한 색상과 setColor 갱신 함수를 ColorPicker 컴포넌트에 전달한다.<br/>

6-1-2 부모 컴포넌트로부터 프롭을 통해 상태 받기<br/>
상태를 공유하는 하위 컴포넌트들로 부터 가장 가까운 공통 상위 부모 컴포넌트에서 공유 상태를 관리한다.<br/>
리액트가 컴포넌트를 호출할 때, 첫 번째 인자로 부모 컴포넌트가 설정한 모든 프롭이 포함된 객체를 전달한다. <br/>
어떤 컴포넌트의 경우 디폴트 값을 설정할 수 있지만, 경우에 따라 다르다.<br/>
따라서 폴백 폴백 ui를 사용하지 않으려면 같은 상태를 사용하는 모든 컴포넌트의 ui가 없어야만 한다.<br/>
만약 프롭이 없으면 컴포넌트가 작동하지 않는데 타당한 디폴트 값도 없다면, 프롭을 지정하지 않았음을 알려주는 예외의 throw할 수 있다.<br/>

gpt 폴백 - 리액트에서 특정 기능이 작동하지 않을 때 대신 보여줄 대체 화면이나 요소를 제공하는 기능<br/>

6-1-3 부모로부터 갱신 함수를 프롭으로 받기<br/>
자식 컴포넌트에게 전달할 공유 상태가 필요하다는 점을 아는 상태에서는 자식 컴포넌트는 set 함수를 호출해서 부모 컴포넌트의 상태를 설정할 수 있다.<br/>
그 후 부모가 재 렌더링됨에 따라 모든 자식 컴포넌트도 갱신된다.<br/>

6-2 컴포넌트를 더 작은 조각으로 분리하기<br/>
리액트는 앱에서 상태를 관리하는 두 방법으로 useState와 useReducer 훅을 제공한다.<br/>
각 훅은 상태를 갱신하고 재렌더링을 촉발하는 수단을 제공한다. 앱을 개발해 나가면서 개별 컴포넌트가 지역 효과, 핸들러 함수, ui에서 직접 지역적인 상태에 접근하는 상황과 ui의 어느 한 부분에서 상태가 변경됨으로 인해 전체 컴포넌트의<br/>
재렌더링을 촉발하게 되는 식으로 상태가 커지고 뒤섞이는 불편한 상황 사이에서 균형을 잡는다.<br/>
예전에는 한 컴포넌트 안에 캡슐화 되어 있던 상태를 공유할 필요가 생긴다. <br/>

6-2-1 컴포넌트 더 큰 앱의 일부분으로 바라보기<br/>
자식 컴포넌트가 없는 단일 함수 컴포넌트는 모든 상태가 지역 영역 안에 있고, ui를 생성하거나 반환할 때 이 지역 상태를 사용할 수 있다.<br/>
























