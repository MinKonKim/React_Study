## useReducer VS useState
- `useReducer`의 장점
    - 복잡한 상태 관리: 여러 개의 상태를 관리하거나 복잡한 상태 전이가 필요한 경우, useReducer가 유용하다. 상태 업데이트 로직이 명확히 정의되어 있어 유지보수가 용이하다.
    - 상태 업데이트 로직 분리: 액션과 리듀서를 통해 상태 업데이트 로직을 깔끔하게 분리할 수 있어, 코드의 가독성이 높아진다.
    - 디버깅 용이: 액션을 사용하여 상태가 어떻게 변화하는지를 추적하기 쉬워 디버깅이 용이하다.
    - 성능 최적화: 여러 상태를 한 번에 업데이트할 수 있어, 불필요한 리렌더링을 줄일 수 있다.

- `useState`의 장점 (props)
    - 간단한 상태 관리: 상태가 단순하고, 하나의 값만을 관리할 때는 useState가 더 직관적이고 사용하기 쉽다.
    - 빠른 프로토타입 제작: 간단한 컴포넌트에서는 useState를 사용하는 것이 더 빠르고 편리하다.
    - 로컬 상태 관리: 컴포넌트 내에서만 필요한 상태를 관리할 때, useState가 더 간단하다.

- 상황에 따른 선택
    - 단순한 상태: 컴포넌트에서 단순한 상태를 관리할 경우 `useState`를 사용하는 것이 더 효율적이다.
    - 복잡한 상태 및 여러 액션: 여러 상태를 관리해야 하거나 상태 업데이트 로직이 복잡한 경우에는 `useReducer`를 사용하는 것이 더 좋다.
    - 상태의 흐름을 추적해야 하는 경우: 디버깅이 중요한 경우에는 `useReducer`가 유리하다.
<br/>

## useCallback 훅을 사용해 함수의 정체성 유지하기
- 렌더링과 렌더링 사이에 `같은 함수`를 계속 사용하지만 그 함수가 계속 재정의되는 일은 막고 싶다면 함수를 `useCallback` 훅에 전달할 수 있다.
- 리액트는 렌더링이 일어날 때마다 이 훅에서 같은 함수를 반환하며, 함수의 `의존 관계`가 변경되는 경우에만 함수를 재정의해 준다.
- useCallback이 반환하는 함수는 의존 관계 목록의 값이 달라지지 않는 한 안정적이다.
- 의존 관계에 속한 값이 변경되면, 리액트는 새로운 의존 관계 값으로 함수를 다시 정의해 `캐싱`하고 반환한다.
- useCallback 훅은 이 훅을 사용하는 경우와 완전히 똑같은 방식으로 프롭들이 변경되는 경우에만 재렌더링되는 컴포넌트와 함께 쓸 때 유용하다.
- 리액트의 memo 함수를 사용하면 이런 (useCallback 훅과 똑같은 방식으로 재렌더링되는) 컴포넌트를 생성할 수 있다.
- 더 일반적으로 값의 재정의나 재계산을 막고 싶은 경우를 위해 리액트는`useMemo` 훅을 제공한다.
<br/>

## 요약
- 컴포넌트가 동일한 상태 값을 공유하면, 그 상태 값을 컴포넌트 트리에서 가장 가까운 공통 조상 컴포넌트로 끌어올리고 프롭들을 통해 하위 컴포넌트에게 내려보내라.
- 공유된 상태를 갱신해야한다면 useState에서 돌려받은 갱신 함수를 하위 컴포넌트에게 전달하라.
- 아무것도 렌더링하지 않는게 적합하다면 null을 반환하라.
- 부모가 관리하는 상태를 자식 컴포넌트가 갱신하게 하려면, 자식에게 갱신 함수나 디스패치 함수를 전달하라. 이렇게 전달받은 함수를 효과에서 사용해야 한다면 효과의 의존 관계 목록에 해당 함수를 포함시켜라.
- useCallback 훅을 사용해 렌더링 사이에 함수의 정체성을 유지하라. useCallback 훅을 사용한 경우, 리액트는 의존관계가 변경됐을 때만 함수를 재정의한다.
