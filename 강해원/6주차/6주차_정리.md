## useMemo로 상태관리하기
  - 우리는 useMemo를 호출해 심각하게 느린 UI 갱신으로부터 사용자를 보호한다.
  - useMemo를 호출할 때는 생성 함수와 의존 관계 목록을 전달해야 한다.
  - 의존 관계 목록은 값의 배열이며, 함수가 계산에 사용하는 모든 값을 포함해야 한다.
  - 각 호출마다 useMemo는 의존 관계 목록을 이전 목록과 비교한다.
  - 각 목록이 같은 값들을 같은 순서로 포함하면 useMemo는 저장된 값을 반환한다.
  - 목록 중에 어떤 값이 달라진 경우에 useMemo는 생성 함수를 호출하고 그 함수가 반환한 값을 저장하고 반환한다.
  - 다시 말해, useMemo는 저장된 값을 반환할 수도 있다.
  - 리액트는 메모리를 해체하기 위해 저장소를 지울 권한을 갖고 있다.
  - 그로 인해 의존 관계에 속한 값이 변경되지 않아도 비용이 많이 드는 함수를 호출할 수도 있다.
  - 의존 관계 목록을 생략하면 useMemo는 항상 함수를 실행한다.
  - 이는 useMemo의 목적에 위배된다.
  - 빈 배열을 전달하면 목록의 값이 절대 변경되지 않으므로 useMemo가 항상 저장된 값을 반환할 수 있다.
  - 그러나 리액트가 저장소를 지우고 함수를 매번 다시 실행하기로 결정할 수도 있다.
  - 거의 대부분의 경우 이런 불확실한 행동 양식을 피하는 것이 최선이다.
<br/>

## 요약
  - 비용이 많이드는 계산을 불필요하게 다시 실행하는 일을 막기 위해, 계산을 useMemo 훅으로 감싸라.
  - useMemo에게 메모화하려는 비용이 많이 드는 함수를 전달하라.
  - 비용이 많이 드는 함수의 의존 관계 목록을 useMemo 훅에게 전달하라.
  - 호출과 호출 사이에 의존 관계 배열의 값이 변경되지 않은 경우 useMemo가 비용이 많이 드는 함수에 대해 저장된 결과를 반환할 수 있다.
  - useMemo가 항상 메모화된 값을 사용하리라 기대하지 마라. 리액트가 메모리를 확보하기 위해 저장된 결과를 폐기할 수 도 있다.
  - 변수의 프로퍼티에 접근해야 하는데 프로퍼티가 정의되지 않았을 수 도 있다면 자바스크립트의 선택적 체이닝 구문과 대괄호를 사용하라. 선택적 체이닝을 쓸 때는 대괄호 뒤에도 마침표를 포함시켜야 한다.
  ```js
  const cellData = bookings?.[session]?.[data] // [session]?[data]가 아니라는 점에 유의!
  ```
